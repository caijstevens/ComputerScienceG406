#wip #cs 

### OS Memory Management 

Keeps track of memory in use or free
- allocates free memory when needed
- deciding processes/data to transfer between RAM and disk

With CPU scheduling can improve CPU utilisation and computer response speed

### Types of Memory 

Many types:
- cache (primary)
- main memory (primary)
- storage memory
- virtual memory

### Hardware 

Process has separate memory space
- pair of **base** and **limit registers** define logical address space
- memory protection required to ensure correct operation
- per-process memory space protects processes from each other

Concept: Logical address space bound to separate **physical address space**
- Logical address: generated by CPU, aka virtual address
- Physical address: address seen by memory unit
- application program deals with logical addresses and doesn't know physical addresses

### MMU and Memory Partitioning

**Memory Management Unit:** device that maps virtual to physical address
- base register now called **relocation register**

Memory is finite resource, should be used as efficiently as possible
- partitioned between kernel and user processes
- partitions kept in single contiguous sections of memory

Relocation registers used to protect processes from each other and from changing OS code/data
- base register contains value of smallest physical address
- limit register contains logical address range (less than limit)
- MMU maps logical address dynamically

Contiguous memory faster to read (in sequence)
- uses holes (blocks of available memory)
- holes scattered throughout memory
- when process arrives, allocated memory from hole
- info maintained about allocated and free holes

![[Screenshot 2025-05-19 at 20.56.54.png]]

Hole allocation strategies:
- First-fit: Allocate first hole that is big enough
- Best-fit: Allocate smallest hole that is big enough
	- searches entire list unless ordered by size
- Worst-fit: Allocate largest hole
	- search entire list

### Fragmentation

**External fragmentation** is memory space that can satisfy request but is not contiguous

**Internal fragmentation** is memory allocated successfully but may be slightly larger than requested amount

First-fit allocation leaves $0.5N$ blocks lost to fragmentation
- reduce ext. fragmentation by **compaction**, shuffle memory to place all free memory together in one large block

### Paging

Physical space can be noncontiguous, process allocated physical memory whenever is available
- avoids ext. fragmentation
- avoids problem of varying sized memory chunks

Physical memory divided into fixed-sized blocks called **frames**
- logical memory divided into blocks of same size called **pages**

To run program of size $n$ pages, find $n$ free frames and load program: **paging**
- **page table** set up to manage mapping of logical to physical using address translation
- int. fragmentation still present

Address Translation Scheme:
- logical memory address generated by CPU divided into page number ($p$) (index into page table with base addresses) and page offset ($d$) (combined with base address to define physical address)![[Screenshot 2025-05-19 at 21.11.38.png]]
- for given logical address space $2^m$ and page size $2^n$

MMU address translation process:
1. extract page number $p$ and use as index into page table
2. extract corresponding frame number $f$ from page table
3. replace $p$ in logical address with $f$
![[Screenshot 2025-05-19 at 21.12.59.png]]

Effective access time:
- hit ratio = $\alpha$: percentage of times that page number found in associative registers

$$EAT = (\text{TLB hit-ratio }\times\text{memory access time } + ((1-\text{TLB hit-ratio})\times(2\times\text{memory access time}))$$

Protection:
- valid-invalid bit attached to each page table entry
- valid indicates that page is in process's logical space and is legal page
- invalid indicates page not in logical space
![[Screenshot 2025-05-19 at 21.16.04.png]]

### Virtual Memory 

**Virtual memory** is the OS capability that allows programs to address more memory locations than actually provided
- eases memory management burden from programmers

Logical address space much larger than physical address space
- pages swapped in and out main memory
- physical space shared by several processes
- only part of process needs to be in physical space for execution
- free frame list maintained by OS

**Virtual address space**: logical view of process stored in memory
- code (read-only)
- data(R/W)
- heap: holds data produced during execution, expands and contracts
- stack: holds instructions/data known at procedure call. 

### Demand Paging and Page Faults

Bring page into memory only when required
- reduces pages to be transferred and frames allocated to process
- increases response time for collection of processes
- increases no. of executing processes

When reference made to page address:
- invalid ref = abort
- not in memory = bring to memory
- valid/invalid bit: 1 = in memory, 0 = not
- if V/I bit in page table entry = 0, page fault trap

If process request to access address is invalid:
- terminate process, clear allocated memory and throw error
If valid:
- if page allocated frame, break
- else if page fault trap:
	- identify free frame
	- read page into frame
	- update page table
	- restart instruction interrupted by page fault trap
	![[Screenshot 2025-05-19 at 21.24.08.png]]
Page fault rate $0\leq p\leq 1$
- if $p=0$, no page fault
- if $p=1$, every ref is fault

Effective Access Time: $$EAT = (1-p)\times\text{memory access } + p\times(\text{page fault overhead + swap page out + swap page in})$$
Page fault overhead includes:
- context switching
- time waiting in paging device or ready queues

### Page Replacement

Occurs when no free frames.
- find page in memory not really used and swap out
- algorithm to decide page, minimise page fault no.

Method:
1. find location of desired page on disk
2. if free frame, use it
3. if no free frame, use page-replacement algorithm to choose victim page
4. write victim page to disk, update page table and FF list
5. read desired page into freed frame
6. update page table and FF list
7. restart user process

Finding and evaluating replacement algorithm:
- run each algorithm on particular string of memory refs
- Compute page faults per algorithm
- Compare number of page faults, aim for lowest